<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue路由 | ALeeLee 的博客 ｜ ALeeLee Blog</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="./favicon.ico">
    <meta name="description" content="个人博客，前端开发">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <link rel="preload" href="./assets/css/0.styles.13617540.css" as="style"><link rel="preload" href="./assets/js/app.d8726ba9.js" as="script"><link rel="preload" href="./assets/js/8.890bf07c.js" as="script"><link rel="preload" href="./assets/js/40.f0daf6a2.js" as="script"><link rel="prefetch" href="./assets/js/10.c70c2fc0.js"><link rel="prefetch" href="./assets/js/11.2721cb8f.js"><link rel="prefetch" href="./assets/js/12.94aa74d4.js"><link rel="prefetch" href="./assets/js/13.3b4b13fc.js"><link rel="prefetch" href="./assets/js/14.5912b5f4.js"><link rel="prefetch" href="./assets/js/15.eadc1f16.js"><link rel="prefetch" href="./assets/js/16.8cd4ac1d.js"><link rel="prefetch" href="./assets/js/17.b8a75fe5.js"><link rel="prefetch" href="./assets/js/18.f5010394.js"><link rel="prefetch" href="./assets/js/19.02c02521.js"><link rel="prefetch" href="./assets/js/2.d2666a5a.js"><link rel="prefetch" href="./assets/js/20.25b1fde1.js"><link rel="prefetch" href="./assets/js/21.5c184a71.js"><link rel="prefetch" href="./assets/js/22.393a1365.js"><link rel="prefetch" href="./assets/js/23.b2439e38.js"><link rel="prefetch" href="./assets/js/24.b76a488b.js"><link rel="prefetch" href="./assets/js/25.289995f1.js"><link rel="prefetch" href="./assets/js/26.a311bd4f.js"><link rel="prefetch" href="./assets/js/27.065351a5.js"><link rel="prefetch" href="./assets/js/28.9b464201.js"><link rel="prefetch" href="./assets/js/29.64c6d04a.js"><link rel="prefetch" href="./assets/js/3.db55bc90.js"><link rel="prefetch" href="./assets/js/30.679ed419.js"><link rel="prefetch" href="./assets/js/31.01a0146b.js"><link rel="prefetch" href="./assets/js/32.8f480b2c.js"><link rel="prefetch" href="./assets/js/33.5a296508.js"><link rel="prefetch" href="./assets/js/34.60bb7ed6.js"><link rel="prefetch" href="./assets/js/35.9900f0e4.js"><link rel="prefetch" href="./assets/js/36.8ec257de.js"><link rel="prefetch" href="./assets/js/37.d176f795.js"><link rel="prefetch" href="./assets/js/38.2ba056f8.js"><link rel="prefetch" href="./assets/js/39.4b348633.js"><link rel="prefetch" href="./assets/js/4.a3e2642d.js"><link rel="prefetch" href="./assets/js/41.9f9dd35e.js"><link rel="prefetch" href="./assets/js/42.9ae29393.js"><link rel="prefetch" href="./assets/js/43.b804381e.js"><link rel="prefetch" href="./assets/js/44.176898f8.js"><link rel="prefetch" href="./assets/js/45.5b351d46.js"><link rel="prefetch" href="./assets/js/46.dfb065e4.js"><link rel="prefetch" href="./assets/js/47.cbd2495f.js"><link rel="prefetch" href="./assets/js/48.37099a30.js"><link rel="prefetch" href="./assets/js/49.098f60f0.js"><link rel="prefetch" href="./assets/js/5.377e4d47.js"><link rel="prefetch" href="./assets/js/6.364979c9.js"><link rel="prefetch" href="./assets/js/7.f092bbd1.js"><link rel="prefetch" href="./assets/js/9.2e890ff5.js">
    <link rel="stylesheet" href="./assets/css/0.styles.13617540.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="global-layout" data-v-7f2e4136><header class="header-container" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(/post-bg.jpeg);" data-v-93921ff8 data-v-7f2e4136><nav class="navbar" style="position:absolute;opacity:1;transition:all 0.5s ease-in-out;" data-v-93921ff8><a href="/./" class="navbar-link router-link-active">
    ALeeLee Blog
  </a> <ul class="navbar-links"><li><a href="/./" class="router-link-active">
        HOME
      </a></li><li><a href="/./about/">
        ABOUT
      </a></li><li><a href="/./tags/">
        TAGS
      </a></li></ul> <div id="nav-icon"><span></span><span></span><span></span></div></nav> <div class="header-title" data-v-93921ff8 data-v-93921ff8><h1 data-v-93921ff8>vue路由</h1> <p data-v-93921ff8></p></div></header> <div class="container" data-v-b3fda33c data-v-7f2e4136><main class="main" style="width:60%;" data-v-b3fda33c><div class="post" data-v-b3fda33c data-v-b3fda33c><article class="main-div"><div class="post-content content content__default"><p>vue路由</p> <h2 id="_1-vue-router-的懒加载如何实现"><a href="#_1-vue-router-的懒加载如何实现" class="header-anchor">#</a> 1. Vue-Router 的懒加载如何实现</h2> <p>非懒加载：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> List <span class="token keyword">from</span> <span class="token string">'@/components/list.vue'</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">'/list'</span><span class="token punctuation">,</span> component<span class="token operator">:</span> List <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><p>（1）方案一(常用)：<strong>ES6推荐方式imprort ()----推荐使用</strong></p> <p>1：直接将组件引入的方式，import是ES6的一个语法标准，如果需要浏览器兼容，需要转化成es5的语法。</p> <p>2：推荐使用这种方式，但是注意wepack的版本&gt;2.4</p> <p>3：vue官方文档中使用的也是import实现路由懒加载</p> <p>4：上面声明导入，下面直接使用</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> Router <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token punctuation">;</span>
<span class="token comment">// 官网可知：下面没有指定webpackChunkName，每个组件打包成一个js文件。</span>
<span class="token keyword">const</span> <span class="token function-variable function">Foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'../components/Foo'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token function-variable function">Aoo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'../components/Aoo'</span><span class="token punctuation">)</span>
<span class="token comment">// 下面2行代码，指定了相同的webpackChunkName，会合并打包成一个js文件。</span>
<span class="token comment">// const Foo = () =&gt; import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/Foo')</span>
<span class="token comment">// const Aoo = () =&gt; import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/Aoo')</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
 routes<span class="token operator">:</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
   path<span class="token operator">:</span> <span class="token string">'/Foo'</span><span class="token punctuation">,</span>
   name<span class="token operator">:</span> <span class="token string">'Foo'</span><span class="token punctuation">,</span>
   component<span class="token operator">:</span> Foo
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
   path<span class="token operator">:</span> <span class="token string">'/Aoo'</span><span class="token punctuation">,</span>
   name<span class="token operator">:</span> <span class="token string">'Aoo'</span><span class="token punctuation">,</span>
   component<span class="token operator">:</span> Aoo
  <span class="token punctuation">}</span>
 <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>



</code></pre></div><p>（2）方案二：<strong>Vue异步加载技术</strong></p> <p>1：vue-router配置路由，使用vue的异步组件技术，可以实现懒加载，此时一个组件会生成一个js文件。</p> <p>2：component: resolve =&gt; require(['放入需要加载的路由地址'], resolve)</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code> <span class="token punctuation">{</span>
 path<span class="token operator">:</span> <span class="token string">'/problem'</span><span class="token punctuation">,</span>
 name<span class="token operator">:</span> <span class="token string">'problem'</span><span class="token punctuation">,</span>
 <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'../pages/home/problemList'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> resolve<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>


</code></pre></div><p>（3）方案三：<strong>webpack提供的require.ensure()实现懒加载：</strong></p> <p>1：vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。</p> <p>2：这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</p> <p>3：require.ensure可实现按需加载资源，包括js,css等。他会给里面require的文件单独打包，不会和主文件打包在一起。</p> <p>4：第一个参数是数组，表明第二个参数里需要依赖的模块，这些会提前加载。</p> <p>5：第二个是回调函数,在这个回调函数里面require的文件会被单独打包成一个chunk,不会和主文件打包在一起，这样就生成了两个chunk,第一次加载时只加载主文件。</p> <p>6：第三个参数是错误回调。</p> <p>7：第四个参数是单独打包的chunk的文件名</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> Router <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">HelloWorld</span><span class="token operator">=</span><span class="token parameter">resolve</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
		require<span class="token punctuation">.</span><span class="token function">ensure</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'@/components/HelloWorld'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
			<span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/HelloWorld'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">'Router'</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
	routes<span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span>
	<span class="token punctuation">{</span>path<span class="token operator">:</span><span class="token string">'./'</span><span class="token punctuation">,</span>
	name<span class="token operator">:</span><span class="token string">'HelloWorld'</span><span class="token punctuation">,</span>
	component<span class="token operator">:</span>HelloWorld
	<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>（4）import和require的比较（了解）</strong></p> <p>1：import 是解构过程并且是编译时执行</p> <p>2：require 是赋值过程并且是运行时才执行，也就是异步加载</p> <p>3：require的性能相对于import稍低，因为require是在运行时才引入模块并且还赋值给某个变量</p> <h2 id="_2-路由的hash和history模式的区别"><a href="#_2-路由的hash和history模式的区别" class="header-anchor">#</a> 2. 路由的hash和history模式的区别</h2> <p>Vue-Router有两种模式：</p> <ul><li><p><strong>hash</strong>模式，用URL hash值来做路由，支持所有浏览器；该模式实现的路由，在通过链接后面添加““#”+路由名字”。</p></li> <li><p><strong>history</strong>模式，由h5提供的history对象实现，依赖H5 History API和服务器配置。</p></li> <li><p><strong>abstract</strong>模式，支持所有JS运行环境，如Node服务器端，如果发现没有浏览器的API，路由会自动强制进入该模式。</p></li></ul> <h4 id="_1-hash模式"><a href="#_1-hash模式" class="header-anchor">#</a> <strong>1.hash模式</strong></h4> <ul><li>url路径会出现 <strong>#</strong> 字符</li> <li>hash值不包括在 <strong>HTTP 请求</strong>中，它是交由前端路由处理，所以改变hash值时不会刷新页面，也不会向服务器发送请求</li> <li>hash值的改变会触发<strong>hashchange</strong>事件</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onhashchange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>oldURL<span class="token punctuation">,</span> event<span class="token punctuation">.</span>newURL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">let</span> hash <span class="token operator">=</span> location<span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。</p> <h4 id="_2-history模式"><a href="#_2-history模式" class="header-anchor">#</a> 2. history模式</h4> <p><strong>简介：</strong> history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。 <strong>特点：</strong> 当使用history模式时，URL就像这样：<a href="https://link.juejin.cn?target=http%3A%2F%2Fabc.com%2Fuser%2Fid" target="_blank" rel="noopener noreferrer">abc.com/user/id<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。 <strong>API：</strong> history api可以分为两大部分，切换历史状态和修改历史状态：</p> <ul><li><strong>修改历史状态</strong>：包括了 HTML5 History Interface 中新增的 <code>pushState()</code> 和 <code>replaceState()</code> 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。</li> <li><strong>切换历史状态：</strong> 包括<code>forward()</code>、<code>back()</code>、<code>go()</code>三个方法，对应浏览器的前进，后退，跳转操作。</li></ul> <p>虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。</p> <p>如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  mode<span class="token operator">:</span> <span class="token string">'history'</span><span class="token punctuation">,</span>
  routes<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="_3-两种模式对比"><a href="#_3-两种模式对比" class="header-anchor">#</a> 3. 两种模式对比</h4> <p>调用 history.pushState() 相比于直接修改 hash，存在以下优势:</p> <ul><li>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；</li> <li>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</li> <li>pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；</li> <li>pushState() 可额外设置 title 属性供后续使用。</li> <li>hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。</li></ul> <p>hash模式和history模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。</p> <h2 id="_3-如何获取页面的hash变化"><a href="#_3-如何获取页面的hash变化" class="header-anchor">#</a> 3. 如何获取页面的hash变化</h2> <p><strong>（1）监听$route的变化</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 监听,当路由发生变化的时候执行</span>
watch<span class="token operator">:</span> <span class="token punctuation">{</span>
  $route<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">val<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 深度观察监听</span>
    deep<span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><p><strong>（2）window.location.hash读取#值</strong>  的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>hash
<span class="token comment">//'#%E4%BA%8C%E3%80%81%E5%A6%82%E4%BD%95%E5%81%9A'</span>

window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'hashchange'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> value <span class="token operator">=</span> location<span class="token punctuation">.</span>hash
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
        <span class="token keyword">switch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token comment">//对应操作</span>
        <span class="token punctuation">}</span>
    
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="_4-route-和-router的区别"><a href="#_4-route-和-router的区别" class="header-anchor">#</a> 4. $route 和$router的区别</h2> <ul><li>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数</li> <li>$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li></ul> <h2 id="_5-如何定义动态路由？如何获取传过来的动态参数？"><a href="#_5-如何定义动态路由？如何获取传过来的动态参数？" class="header-anchor">#</a> 5. 如何定义动态路由？如何获取传过来的动态参数？</h2> <p><strong>（1）param方式</strong></p> <ul><li>配置路由格式：<code>/router/:id</code></li> <li>传递的方式：在path后面跟上对应的值</li> <li>传递后形成的路径：<code>/router/123</code></li></ul> <p>1）路由定义</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//在APP.vue中</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">&quot;'/user/'+userId&quot;</span> replace<span class="token operator">&gt;</span>用户<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span>    

<span class="token comment">//在index.js</span>
<span class="token punctuation">{</span>
   path<span class="token operator">:</span> <span class="token string">'/user/:userid'</span><span class="token punctuation">,</span>
   component<span class="token operator">:</span> User<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>

</code></pre></div><p>2）路由跳转</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 方法1：</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">&quot;{ name: 'users', params: { uname: wade }}&quot;</span><span class="token operator">&gt;</span>按钮<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link

<span class="token comment">// 方法2：</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">'users'</span><span class="token punctuation">,</span>params<span class="token operator">:</span><span class="token punctuation">{</span>uname<span class="token operator">:</span>wade<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 方法3：</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'/user/'</span> <span class="token operator">+</span> wade<span class="token punctuation">)</span>

</code></pre></div><p>3）参数获取 通过 <code>$route.params.userid</code> 获取传递的值</p> <p><strong>（2）query方式</strong></p> <ul><li>配置路由格式：<code>/router</code>，也就是普通配置</li> <li>传递的方式：对象中使用query的key作为传递方式</li> <li>传递后形成的路径：<code>/route?id=123</code></li></ul> <p>1）路由定义</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//方式1：直接在router-link 标签上以对象的形式</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">&quot;{path:'/profile',query:{name:'why',age:28,height:188}}&quot;</span><span class="token operator">&gt;</span>档案<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span>

<span class="token comment">// 方式2：写成按钮以点击事件形式</span>
<span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">'profileClick'</span><span class="token operator">&gt;</span>我的<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>    

<span class="token function">profileClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    path<span class="token operator">:</span> <span class="token string">&quot;/profile&quot;</span><span class="token punctuation">,</span>
    query<span class="token operator">:</span> <span class="token punctuation">{</span>
        name<span class="token operator">:</span> <span class="token string">&quot;kobi&quot;</span><span class="token punctuation">,</span>
        age<span class="token operator">:</span> <span class="token string">&quot;28&quot;</span><span class="token punctuation">,</span>
        height<span class="token operator">:</span> <span class="token number">198</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>2）跳转方法</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 方法1：</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">&quot;{ name: 'users', query: { uname: james }}&quot;</span><span class="token operator">&gt;</span>按钮<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span>

<span class="token comment">// 方法2：</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'users'</span><span class="token punctuation">,</span> query<span class="token operator">:</span><span class="token punctuation">{</span> uname<span class="token operator">:</span>james <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 方法3：</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">&quot;{ path: '/user', query: { uname:james }}&quot;</span><span class="token operator">&gt;</span>按钮<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span>

<span class="token comment">// 方法4：</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">'/user'</span><span class="token punctuation">,</span> query<span class="token operator">:</span><span class="token punctuation">{</span> uname<span class="token operator">:</span>james <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 方法5：</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'/user?uname='</span> <span class="token operator">+</span> jsmes<span class="token punctuation">)</span>
</code></pre></div><p>3）获取参数</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>通过$route<span class="token punctuation">.</span>query 获取传递的值
</code></pre></div><h2 id="_6-vue-router-路由钩子在生命周期的体现"><a href="#_6-vue-router-路由钩子在生命周期的体现" class="header-anchor">#</a> 6. Vue-router 路由钩子在生命周期的体现</h2> <p>一、Vue-Router导航守卫</p> <p>有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。 为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的</p> <ol><li>全局路由钩子</li></ol> <p>vue-router全局有三个路由钩子;</p> <ul><li>router.beforeEach 全局前置守卫 进入路由之前</li> <li>router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用</li> <li>router.afterEach 全局后置钩子 进入路由之后</li></ul> <p>具体使用∶</p> <ul><li>beforeEach（判断是否登录了，没登录就跳转到登录页）</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  
    <span class="token keyword">let</span> ifInfo <span class="token operator">=</span> <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$common<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token string">'userData'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 判断是否登录的存储信息</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ifInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token comment">// sessionStorage里没有储存user信息    </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">.</span>path <span class="token operator">==</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            <span class="token comment">//如果是登录页面路径，就直接next()      </span>
            <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> 
            <span class="token comment">//不然就跳转到登录      </span>
            Message<span class="token punctuation">.</span><span class="token function">warning</span><span class="token punctuation">(</span><span class="token string">&quot;请重新登录！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     
            window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$loginUrl<span class="token punctuation">;</span>    
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    
        <span class="token keyword">return</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><ul><li>afterEach （跳转之后滚动条回到顶部）</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>router<span class="token punctuation">.</span><span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  
    <span class="token comment">// 跳转之后滚动条回到顶部  </span>
    window<span class="token punctuation">.</span><span class="token function">scrollTo</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><ol><li>单个路由独享钩子</li></ol> <p><strong>beforeEnter</strong> 如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">[</span>    
    <span class="token punctuation">{</span>        
        path<span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>        
        name<span class="token operator">:</span> <span class="token string">'login'</span><span class="token punctuation">,</span>        
        component<span class="token operator">:</span> login<span class="token punctuation">,</span>        
        <span class="token function-variable function">beforeEnter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>          
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'即将进入登录页面'</span><span class="token punctuation">)</span>          
            <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        
        <span class="token punctuation">}</span>    
    <span class="token punctuation">}</span>
<span class="token punctuation">]</span>

</code></pre></div><ol><li>组件内钩子</li></ol> <p>beforeRouteUpdate、beforeRouteEnter、beforeRouteLeave</p> <p>这三个钩子都有三个参数∶to、from、next</p> <ul><li>beforeRouteEnter∶ 进入组件前触发</li> <li>beforeRouteUpdate∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo/∶id，在 /foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的foo组件，这个钩子在这种情况下就会被调用</li> <li>beforeRouteLeave∶ 离开组件被调用</li></ul> <p>注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">beforeRouteEnter</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      
    <span class="token function">next</span><span class="token punctuation">(</span><span class="token parameter">target</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">.</span>path <span class="token operator">==</span> <span class="token string">'/classProcess'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          
            target<span class="token punctuation">.</span>isFromProcess <span class="token operator">=</span> <span class="token boolean">true</span>        
        <span class="token punctuation">}</span>      
    <span class="token punctuation">}</span><span class="token punctuation">)</span>    
<span class="token punctuation">}</span>
</code></pre></div><p>二、Vue路由钩子在生命周期函数的体现</p> <ol><li>完整的路由导航解析流程（不包括其他生命周期）</li></ol> <ul><li>触发进入其他路由。</li> <li>调用要离开路由的组件守卫beforeRouteLeave</li> <li>调用局前置守卫∶ beforeEach</li> <li>在重用的组件里调用 beforeRouteUpdate</li> <li>调用路由独享守卫 beforeEnter。</li> <li>解析异步路由组件。</li> <li>在将要进入的路由组件中调用 beforeRouteEnter</li> <li>调用全局解析守卫 beforeResolve</li> <li>导航被确认。</li> <li>调用全局后置钩子的 afterEach 钩子。</li> <li>触发DOM更新（mounted）。</li> <li>执行beforeRouteEnter 守卫中传给 next 的回调函数</li></ul> <ol start="2"><li>触发钩子的完整顺序</li></ol> <p>路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶</p> <ul><li>beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。</li> <li>beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。</li> <li>beforeEnter：路由独享守卫</li> <li>beforeRouteEnter：路由组件的组件进入路由前钩子。</li> <li>beforeResolve：路由全局解析守卫</li> <li>afterEach：路由全局后置钩子</li> <li>beforeCreate：组件生命周期，不能访问tAis。</li> <li>created;组件生命周期，可以访问tAis，不能访问dom。</li> <li>beforeMount：组件生命周期</li> <li>deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。</li> <li>mounted：访问/操作dom。</li> <li>activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。</li> <li>执行beforeRouteEnter回调函数next。</li></ul> <ol start="3"><li>导航行为被触发到导航完成的整个过程</li></ol> <ul><li>导航行为被触发，此时导航未被确认。</li> <li>在失活的组件里调用离开守卫 beforeRouteLeave。</li> <li>调用全局的 beforeEach守卫。</li> <li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li> <li>在路由配置里调用 beforeEnteY。</li> <li>解析异步路由组件（如果有）。</li> <li>在被激活的组件里调用 beforeRouteEnter。</li> <li>调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。</li> <li>导航被确认。</li> <li>调用全局的 afterEach 钩子。</li> <li>非重用组件，开始组件实例的生命周期：beforeCreate&amp;created、beforeMount&amp;mounted</li> <li>触发 DOM 更新。</li> <li>用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。</li> <li>导航完成</li></ul> <h2 id="_7-vue-router跳转和location-href有什么区别"><a href="#_7-vue-router跳转和location-href有什么区别" class="header-anchor">#</a> 7. Vue-router跳转和location.href有什么区别</h2> <ul><li>使用 <code>location.href= /url</code>来跳转，简单方便，但是刷新了页面；</li> <li>使用 <code>history.pushState( /url )</code> ，无刷新页面，静态跳转；</li> <li>引进 router ，然后使用 <code>router.push( /url )</code> 来跳转，使用了 <code>diff</code> 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 <code>history.pushState()</code> 没什么差别的，因为vue-router就是用了 <code>history.pushState()</code> ，尤其是在history模式下。</li></ul> <h2 id="_8-params和query的区别"><a href="#_8-params和query的区别" class="header-anchor">#</a> 8. params和query的区别</h2> <p><strong>用法</strong>：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 <code>this.$route.query.name</code> 和 <code>this.$route.params.name</code> 。</p> <p><strong>url地址显示</strong>：query更加类似于ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</p> <p><strong>注意</strong>：query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据。</p> <h2 id="_9-vue-router-导航守卫有哪些"><a href="#_9-vue-router-导航守卫有哪些" class="header-anchor">#</a> 9. Vue-router 导航守卫有哪些</h2> <ul><li>全局前置/钩子：beforeEach、beforeResolve、afterEach</li> <li>路由独享的守卫：beforeEnter</li> <li>组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</li></ul> <h2 id="_10-对前端路由的理解"><a href="#_10-对前端路由的理解" class="header-anchor">#</a> 10. 对前端路由的理解</h2> <p>在前端技术早期，一个 url 对应一个页面，如果要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——用户只有在刷新页面的情况下，才可以重新去请求数据。</p> <p>后来，改变发生了——Ajax 出现了，它允许人们在不刷新页面的情况下发起请求；与之共生的，还有“不刷新页面即可更新页面内容”这种需求。在这样的背景下，出现了 <strong>SPA（单页面应用</strong>）。</p> <p>SPA极大地提升了用户体验，它允许页面在不刷新的情况下更新页面内容，使内容的切换更加流畅。但是在 SPA 诞生之初，人们并没有考虑到“定位”这个问题——在内容切换前后，页面的 URL 都是一样的，这就带来了两个问题：</p> <ul><li>SPA 其实并不知道当前的页面“进展到了哪一步”。可能在一个站点下经过了反复的“前进”才终于唤出了某一块内容，但是此时只要刷新一下页面，一切就会被清零，必须重复之前的操作、才可以重新对内容进行定位——SPA 并不会“记住”你的操作。</li> <li>由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息</li></ul> <p>为了解决这个问题，前端路由出现了。</p> <p>前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。</p> <p>那么如何实现这个目的呢？首先要解决两个问题：</p> <ul><li>当用户刷新页面时，浏览器会默认根据当前 URL 对资源进行重新定位（发送请求）。这个动作对 SPA 是不必要的，因为我们的 SPA 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录。</li> <li>单页面应用对服务端来说，就是一个URL、一套资源，那么如何做到用“不同的URL”来映射不同的视图内容呢？</li></ul> <p>从这两个问题来看，服务端已经完全救不了这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢？作为前端，可以提供这样的解决思路：</p> <ul><li>拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉。</li> <li>感知 URL 的变化。这里不是说要改造 URL、凭空制造出 N 个 URL 来。而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理——这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。</li></ul></div></article> <!----></div></main> <aside class="aside" data-v-b3fda33c data-v-b3fda33c><div class="info-card main-div" data-v-1311ce9e data-v-b3fda33c><div class="info-card-header" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(/avatar-bg.jpeg);" data-v-1311ce9e><img src="/avatar-top.jpg" alt="ALeeLee" class="info-avatar" data-v-1311ce9e></div> <div class="info-card-body" data-v-1311ce9e><section class="info-name" data-v-1311ce9e>
      ALeeLee
    </section> <section class="info-desc" data-v-1311ce9e>In me the tiger sniffs the rose<br/>心有猛虎，细嗅蔷薇</section> <section class="info-contact" data-v-1311ce9e><section data-v-1311ce9e><span data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:1em;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-location" data-v-1311ce9e data-v-1311ce9e></use></svg><span class="info-text" data-v-1311ce9e data-v-1311ce9e>
          Chongqing, China
        </span></span></section> <!----> <section data-v-1311ce9e><span data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:1em;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-email" data-v-1311ce9e data-v-1311ce9e></use></svg><span class="info-text" data-v-1311ce9e data-v-1311ce9e>
          1102721073@qq.com
        </span></span></section></section></div> <div class="info-card-footer" data-v-1311ce9e><p class="footer-sns-link" data-v-1311ce9e><a target="_blank" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-jianshu" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" href="" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-weibo" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-zhihu" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a><a target="_blank" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-github" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a></p></div></div> <div class="post-toc main-div aside-toc" style="position:relative;top:0;width:0px;" data-v-b3fda33c><h4>- CATALOG</h4> <div class="post-nav-toc"><ul><li><a href="/./posts/2022/08/06/vue%E8%B7%AF%E7%94%B1.html#_1-vue-router-的懒加载如何实现">1. Vue-Router 的懒加载如何实现</a></li><li><a href="/./posts/2022/08/06/vue%E8%B7%AF%E7%94%B1.html#_2-路由的hash和history模式的区别">2. 路由的hash和history模式的区别</a></li><li><a href="/./posts/2022/08/06/vue%E8%B7%AF%E7%94%B1.html#_3-如何获取页面的hash变化">3. 如何获取页面的hash变化</a></li><li><a href="/./posts/2022/08/06/vue%E8%B7%AF%E7%94%B1.html#_4-route-和-router的区别">4. $route 和$router的区别</a></li><li><a href="/./posts/2022/08/06/vue%E8%B7%AF%E7%94%B1.html#_5-如何定义动态路由？如何获取传过来的动态参数？">5. 如何定义动态路由？如何获取传过来的动态参数？</a></li><li><a href="/./posts/2022/08/06/vue%E8%B7%AF%E7%94%B1.html#_6-vue-router-路由钩子在生命周期的体现">6. Vue-router 路由钩子在生命周期的体现</a></li><li><a href="/./posts/2022/08/06/vue%E8%B7%AF%E7%94%B1.html#_7-vue-router跳转和location-href有什么区别">7. Vue-router跳转和location.href有什么区别</a></li><li><a href="/./posts/2022/08/06/vue%E8%B7%AF%E7%94%B1.html#_8-params和query的区别">8. params和query的区别</a></li><li><a href="/./posts/2022/08/06/vue%E8%B7%AF%E7%94%B1.html#_9-vue-router-导航守卫有哪些">9. Vue-router 导航守卫有哪些</a></li><li><a href="/./posts/2022/08/06/vue%E8%B7%AF%E7%94%B1.html#_10-对前端路由的理解">10. 对前端路由的理解</a></li></ul></div></div></aside></div> <footer class="footer" data-v-7f2e4136><p class="footer-sns-link"><a target="_blank" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-jianshu"></use></svg></span></a><a target="_blank" href="" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-weibo"></use></svg></span></a><a target="_blank" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-zhihu"></use></svg></span></a><a target="_blank" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-github"></use></svg></span></a></p> <div class="copyright"><span id="custom">Copyright &copy; ALeeLee Blog 2020 <br /> 
      Theme By <a href="https://www.vuepress.cn/" target="_blank">VuePress</a>
      | <a href="https://www.github.com/youdeliang/" target="_blank">youdeliang</a></span> <iframe frameborder="0" scrolling="0" width="80px" height="20px" class="footer-btn" style="margin-left: 2px; margin-bottom:-5px;"></iframe></div></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="./assets/js/app.d8726ba9.js" defer></script><script src="./assets/js/8.890bf07c.js" defer></script><script src="./assets/js/40.f0daf6a2.js" defer></script>
  </body>
</html>
